<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>Stream Extraction Test - AV Library</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/css/bootstrap.min.css" rel="stylesheet">
    <style>
        body { background: #f8f6f2; padding: 20px; }
        .container { max-width: 900px; }
        .test-section { background: white; padding: 20px; margin: 20px 0; border-radius: 8px; box-shadow: 0 2px 8px rgba(0,0,0,0.1); }
        pre { background: #f5f5f5; padding: 15px; border-radius: 4px; overflow-x: auto; }
        .success { color: green; }
        .error { color: red; }
        .info { color: blue; }
    </style>
</head>
<body>
    <div class="container">
        <h1 class="mb-4">Jable.tv 流媒體連結提取測試</h1>
        
        <div class="test-section">
            <h3>測試配置</h3>
            <div class="mb-3">
                <label for="videoUrl" class="form-label">影片 URL:</label>
                <input type="text" id="videoUrl" class="form-control" value="https://jable.tv/s0/videos/ssni-865/" placeholder="輸入影片 URL">
            </div>
            <button class="btn btn-primary" onclick="testExtraction()">開始測試</button>
            <button class="btn btn-secondary ms-2" onclick="testWithRawFetch()">使用直接 Fetch 測試</button>
            <button class="btn btn-danger ms-2" onclick="testWithNetworkMonitor()">監聽網路請求</button>
            <button class="btn btn-info ms-2" onclick="searchInPreview()">在預覽中搜尋流</button>
            <button class="btn btn-secondary ms-2" onclick="clearLog()">清除日誌</button>
        </div>

        <div class="test-section">
            <h3>測試日誌</h3>
            <div id="log" style="max-height: 500px; overflow-y: auto; font-family: monospace; font-size: 12px;"></div>
        </div>

        <div class="test-section">
            <h3>提取結果</h3>
            <div id="results"></div>
        </div>

        <div class="test-section">
            <h3>原始 HTML 預覽</h3>
            <div id="htmlPreview" style="max-height: 400px; overflow-y: auto; font-family: monospace; font-size: 12px; background: #f5f5f5; padding: 10px; border-radius: 4px; white-space: pre-wrap; word-break: break-all;"></div>
        </div>

        <div class="test-section">
            <h3>視頻播放器測試</h3>
            <div id="playerSection" style="display: none;">
                <button class="btn btn-success mb-3" onclick="testPlayback()">測試播放</button>
                <video id="testPlayer" width="100%" height="400" controls style="background: black; border-radius: 4px; display: none;"></video>
                <div id="playerLog" style="margin-top: 10px; max-height: 200px; overflow-y: auto; font-family: monospace; font-size: 12px; background: #f5f5f5; padding: 10px; border-radius: 4px;"></div>
            </div>
        </div>
    </div>

    <script>
        let currentStreams = [];

        const log = (message, type) => {
            type = type || 'info';
            const logDiv = document.getElementById('log');
            const timestamp = new Date().toLocaleTimeString();
            const className = type === 'error' ? 'error' : type === 'success' ? 'success' : 'info';
            logDiv.innerHTML += '<div class="' + className + '">[' + timestamp + '] ' + message + '</div>';
            logDiv.scrollTop = logDiv.scrollHeight;
        };

        const clearLog = () => {
            document.getElementById('log').innerHTML = '';
            document.getElementById('results').innerHTML = '';
        };

        const extractStreamFromHtml = (html) => {
            log('開始分析 HTML...', 'info');
            const streams = [];

            // 檢查是否有 blob URL（說明 JavaScript 被執行了或頁面需要 JS）
            const blobUrls = html.match(/blob:[^\s"'<>]+/g);
            if (blobUrls) {
                log('⚠️ 找到 blob URL（動態生成）：' + blobUrls[0], 'error');
                log('⚠️ 這表示流 URL 是由 JavaScript 動態生成的，需要執行 JS 代碼', 'error');
            }

            // 策略 1: 搜尋 hlsUrl JavaScript 變數 (最直接)
            log('策略 1: 搜尋 hlsUrl 變數...', 'info');
            const hlsMatch = html.match(/var\s+hlsUrl\s*=\s*['"]([^'"]+\.m3u8[^'"]*)['"]/i);
            if (hlsMatch && hlsMatch[1]) {
                streams.push({ source: 'hlsUrl', url: hlsMatch[1], method: 1, priority: 0.5 });
                log('✓ 找到 hlsUrl: ' + hlsMatch[1].substring(0, 100) + '...', 'success');
            }

            // 策略 1b: 替代 hlsUrl 模式
            const hlsMatch2 = html.match(/hlsUrl\s*[:=]\s*['"]([^'"]+\.m3u8[^'"]*)['"]/i);
            if (hlsMatch2 && hlsMatch2[1] && !streams.find(s => s.url === hlsMatch2[1])) {
                streams.push({ source: 'hlsUrl_alt', url: hlsMatch2[1], method: 1, priority: 0.7 });
                log('✓ 找到 hlsUrl (替代): ' + hlsMatch2[1].substring(0, 100) + '...', 'success');
            }

            // 策略 2: 搜尋 poster 屬性中的圖片 URL
            log('策略 2: 搜尋 poster 屬性...', 'info');
            const posterMatch = html.match(/poster="([^"]+)"/);
            if (posterMatch) {
                log('✓ 找到 poster: ' + posterMatch[1], 'success');
            }

            // 策略 3: 在 JavaScript 配置中尋找流源
            log('策略 3: 在 JavaScript 配置中搜尋...', 'info');
            const jsSourcePatterns = [
                /sources\s*:\s*\[\s*\{\s*src\s*:\s*["']([^"']+)["']/i,
                /mp\.options\.sources.*?src\s*:\s*["']([^"']+)["']/i,
                /"url"\s*:\s*["']([^"']+\.(?:m3u8|mp4))["']/i,
                /'url'\s*:\s*["']([^"']+\.(?:m3u8|mp4))["']/i,
                /src\s*:\s*["'](https?:\/\/[^"']+\.(?:m3u8|mp4))["']/i
            ];

            for (let pattern of jsSourcePatterns) {
                const match = html.match(pattern);
                if (match && match[1]) {
                    const url = match[1];
                    if (!streams.find(s => s.url === url)) {
                        streams.push({ source: 'js_config', url: url, method: 3, priority: 2 });
                        log('✓ 在 JS 配置中找到: ' + url.substring(0, 100) + '...', 'success');
                    }
                }
            }

            // 策略 4: 尋找 m3u8 連結
            log('策略 4: 搜尋直接 m3u8 URL...', 'info');
            const m3u8Direct = html.match(/https?:\/\/[^\s"'<>]*\.m3u8[^\s"'<>]*/i);
            if (m3u8Direct) {
                const url = m3u8Direct[0].replace(/[;'"]$/, '');
                if (!streams.find(s => s.url === url)) {
                    streams.push({ source: 'm3u8', url: url, method: 4, priority: 1 });
                    log('✓ 找到直接 m3u8: ' + url.substring(0, 100) + '...', 'success');
                }
            }

            // 策略 5: 在所有 URL 中搜尋潛在的流
            log('策略 5: 搜尋潛在流 URL 模式...', 'info');
            const cdnPatterns = [
                /https?:\/\/[^\s"'<>]*cdn[^\s"'<>]*\.(?:m3u8|mp4)/gi,
                /https?:\/\/[^\s"'<>]*stream[^\s"'<>]*\.(?:m3u8|mp4)/gi,
                /https?:\/\/[^\s"'<>]*video[^\s"'<>]*\.(?:m3u8|mp4)/gi
            ];

            for (let pattern of cdnPatterns) {
                let match;
                while ((match = pattern.exec(html)) !== null) {
                    const url = match[0].replace(/["';]$/, '');
                    if (!streams.find(s => s.url === url)) {
                        streams.push({ source: 'cdn', url: url, method: 5, priority: 3 });
                        log('✓ 找到 CDN URL: ' + url.substring(0, 100) + '...', 'success');
                    }
                }
            }

            // 策略 6: 廣泛搜尋所有 m3u8
            log('策略 6: 廣泛搜尋所有 m3u8...', 'info');
            const m3u8Pattern = /https?:\/\/[^\s"'<>]+\.m3u8(?:[^\s"'<>]*)?/gi;
            let match;
            let count = 0;
            while ((match = m3u8Pattern.exec(html)) !== null) {
                const url = match[0].replace(/["';]$/, '');
                if (url && url.endsWith('.m3u8')) {
                    if (!streams.find(s => s.url === url)) {
                        streams.push({ source: 'm3u8', url: url, method: 6, priority: 2 + count });
                        log('✓ 廣泛搜尋 M3U8 ' + (++count) + ': ' + url.substring(0, 80) + '...', 'success');
                    }
                }
            }

            // 策略 7: 搜尋 .ts 文件並推斷 m3u8 路徑
            log('策略 7: 搜尋 .ts 文件並推斷 m3u8...', 'info');
            const tsMatch = html.match(/https?:\/\/[^\s"'<>]*\/(vod\/\d+\/\d+\/)\d+\.ts[^\s"'<>]*/i);
            if (tsMatch) {
                const baseUrl = tsMatch[0].split('/').slice(0, -1).join('/');
                const m3u8Url = baseUrl + '/playlist.m3u8';
                if (!streams.find(s => s.url === m3u8Url)) {
                    streams.push({ source: 'ts_inferred', url: m3u8Url, method: 7, priority: 1.5 });
                    log('✓ 從 TS 推斷 M3U8: ' + m3u8Url.substring(0, 100) + '...', 'success');
                }
            }

            // 策略 8: 搜尋所有 MP4
            log('策略 8: 搜尋 MP4 連結...', 'info');
            const mp4Regex = /https?:\/\/[^\s"'<>]+\.mp4/gi;
            const mp4Matches = html.match(mp4Regex) || [];
            log('找到 ' + mp4Matches.length + ' 個 MP4 連結', 'info');
            
            for (let i = 0; i < mp4Matches.length && i < 5; i++) {
                if (!streams.find(s => s.url === mp4Matches[i])) {
                    streams.push({ source: 'mp4', url: mp4Matches[i], method: 8, priority: 7 + i });
                    log('✓ MP4 ' + (i + 1) + ': ' + mp4Matches[i].substring(0, 80) + '...', 'success');
                }
            }

            // 策略 9: 搜尋 Blob URL 並分析附近的 JavaScript 代碼
            log('策略 9: 分析 Blob URL 附近的代碼...', 'info');
            const blobPattern = /blob:[^\s"'<>]+/;
            if (blobPattern.test(html)) {
                log('⚠️ 檢測到 blob URL - 這表示頁面使用 JavaScript 動態加載流', 'error');
                log('需要執行 JavaScript 或尋找 JavaScript 中的原始流 URL', 'error');
                
                // 嘗試從 blob URL 附近提取信息
                const blobContext = html.match(/blob:[^\s"'<>]+[^<]*{[^}]*}/);
                if (blobContext) {
                    log('找到 blob 上下文: ' + blobContext[0].substring(0, 200), 'info');
                }
            }

            // 排序（優先級高在前）
            streams.sort((a, b) => a.priority - b.priority);

            log('====== 總計: ' + streams.length + ' 個流媒體連結 (已排序) ======', 'info');
            return streams;
        };

        const testExtraction = async () => {
            clearLog();
            const videoUrl = document.getElementById('videoUrl').value;
            
            if (!videoUrl) {
                log('請輸入影片 URL', 'error');
                return;
            }

            log('開始測試: ' + videoUrl, 'info');

            try {
                // 嘗試方法 1: 標準 Jina
                log('方法 1: 使用標準 Jina 代理', 'info');
                let jinaUrl = 'https://r.jina.ai/' + videoUrl;
                let html = await fetchFromJinaWithHtmlMode(jinaUrl);
                
                if (!html || html.includes('Markdown Content:')) {
                    log('⚠️ 標準方法返回 Markdown，嘗試 HTML 模式...', 'error');
                    
                    // 嘗試方法 2: 添加 ?Accept=text/html
                    log('方法 2: 請求 HTML 格式...', 'info');
                    jinaUrl = 'https://r.jina.ai/' + videoUrl + '?Accept=text/html';
                    html = await fetchFromJinaWithHtmlMode(jinaUrl);
                }
                
                if (!html) {
                    throw new Error('無法從 Jina 獲取內容');
                }

                log('✓ 成功獲取頁面 (' + html.length + ' 字元)', 'success');

                // 顯示原始 HTML
                const preview = document.getElementById('htmlPreview');
                preview.textContent = html.substring(0, 3000);

                // 檢查內容格式
                if (html.includes('<') && html.includes('>')) {
                    log('✅ 檢測到 HTML 格式', 'success');
                } else if (html.includes('Markdown Content:')) {
                    log('⚠️ 仍然是 Markdown 格式', 'error');
                    log('前 500 字: ' + html.substring(0, 500), 'info');
                } else {
                    log('⚠️ 未知格式', 'error');
                }

                const streams = extractStreamFromHtml(html);
                currentStreams = streams;
                displayResults(streams);

            } catch (error) {
                log('✗ 錯誤: ' + error.message, 'error');
            }
        };

        const fetchFromJinaWithHtmlMode = async (jinaUrl) => {
            try {
                const response = await fetch(jinaUrl, {
                    headers: {
                        'Accept': 'text/html',
                        'User-Agent': 'Mozilla/5.0'
                    }
                });
                if (!response.ok) {
                    throw new Error('HTTP ' + response.status);
                }
                return await response.text();
            } catch (error) {
                log('Jina 請求失敗: ' + error.message, 'error');
                return null;
            }
        };

        const testWithRawFetch = async () => {
            clearLog();
            const videoUrl = document.getElementById('videoUrl').value;
            
            if (!videoUrl) {
                log('請輸入影片 URL', 'error');
                return;
            }

            log('開始直接 Fetch 測試: ' + videoUrl, 'info');

            try {
                log('正在嘗試直接 fetch...', 'info');
                
                const response = await fetch(videoUrl, {
                    headers: {
                        'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36'
                    }
                });
                
                if (!response.ok) {
                    throw new Error('HTTP ' + response.status);
                }

                const html = await response.text();
                log('✓ 成功直接獲取頁面 (' + html.length + ' 字元)', 'success');

                const streams = extractStreamFromHtml(html);
                currentStreams = streams;
                displayResults(streams);

            } catch (error) {
                log('✗ 直接 fetch 失敗: ' + error.message + ', 嘗試 Jina 代理...', 'error');
                testExtraction();
            }
        };

        const displayResults = (streams) => {
            const resultsDiv = document.getElementById('results');
            
            if (streams.length === 0) {
                resultsDiv.innerHTML = '<div class="alert alert-warning">未找到任何流媒體連結</div>';
                return;
            }

            let html = '<div class="alert alert-success">找到 ' + streams.length + ' 個流媒體連結</div>';
            
            // M3U8 連結
            const m3u8Links = streams.filter((s) => s.url.includes('.m3u8'));
            if (m3u8Links.length > 0) {
                html += '<h5>M3U8 連結 (推薦用於播放)</h5>';
                for (let i = 0; i < m3u8Links.length; i++) {
                    const link = m3u8Links[i];
                    const idx = streams.indexOf(link);
                    html += '<div style="margin: 5px 0; padding: 10px; background: #e3f2fd; border-left: 4px solid #1976d2; border-radius: 4px;">' +
                        '<small><strong>方法 ' + link.method + ' (' + link.source + '):</strong></small><br>' +
                        '<code style="word-break: break-all; font-size: 11px;">' + link.url + '</code><br>' +
                        '<button class="btn btn-sm btn-primary" onclick="handleTestStream(' + idx + ')">測試播放</button> ' +
                        '<button class="btn btn-sm btn-secondary" onclick="handleCopyUrl(' + idx + ')">複製 URL</button>' +
                        '</div>';
                }
            }
            
            // 其他連結
            const otherLinks = streams.filter((s) => !s.url.includes('.m3u8'));
            if (otherLinks.length > 0) {
                html += '<hr><h5>其他連結</h5>';
                html += '<table class="table table-sm table-bordered">' +
                    '<thead><tr><th>方法</th><th>來源</th><th>URL</th><th>操作</th></tr></thead>' +
                    '<tbody>';
                
                for (let i = 0; i < otherLinks.length; i++) {
                    const stream = otherLinks[i];
                    const idx = streams.indexOf(stream);
                    const shortUrl = stream.url.substring(0, 50) + (stream.url.length > 50 ? '...' : '');
                    html += '<tr>' +
                        '<td>' + stream.method + '</td>' +
                        '<td>' + stream.source + '</td>' +
                        '<td title="' + stream.url + '"><small>' + shortUrl + '</small></td>' +
                        '<td>' +
                        '<button class="btn btn-sm btn-primary" onclick="handleTestStream(' + idx + ')">測試</button> ' +
                        '<button class="btn btn-sm btn-secondary" onclick="handleCopyUrl(' + idx + ')">複製</button>' +
                        '</td>' +
                        '</tr>';
                }
                
                html += '</tbody></table>';
            }

            resultsDiv.innerHTML = html;
            document.getElementById('playerSection').style.display = 'block';
        };

        const handleTestStream = (idx) => {
            if (idx >= 0 && idx < currentStreams.length) {
                testStream(currentStreams[idx].url, idx);
            }
        };

        const handleCopyUrl = (idx) => {
            if (idx >= 0 && idx < currentStreams.length) {
                copyToClipboard(currentStreams[idx].url);
            }
        };

        const testStream = async (url, idx) => {
            const playerLog = document.getElementById('playerLog');
            playerLog.innerHTML = '';

            const logPlayer = (msg, type) => {
                type = type || 'info';
                const className = type === 'error' ? 'error' : type === 'success' ? 'success' : 'info';
                playerLog.innerHTML += '<div class="' + className + '">' + msg + '</div>';
            };

            logPlayer('測試流 #' + (idx + 1) + ': ' + url.substring(0, 80) + '...', 'info');

            const player = document.getElementById('testPlayer');
            player.style.display = 'block';
            
            try {
                logPlayer('正在檢查 URL 可訪問性...', 'info');
                const response = await fetch(url, { method: 'HEAD', mode: 'no-cors' });
                logPlayer('✓ URL 可訪問 (狀態: ' + response.status + ')', 'success');

                logPlayer('正在設置播放器...', 'info');
                player.src = url;
                logPlayer('✓ 播放器已設置', 'success');
                logPlayer('您可以點擊播放按鈕嘗試播放', 'info');

            } catch (error) {
                logPlayer('✗ 錯誤: ' + error.message, 'error');
            }
        };

        const testPlayback = () => {
            const player = document.getElementById('testPlayer');
            if (!player.src) {
                alert('請先測試一個流連結');
                return;
            }
            player.play().catch((err) => {
                alert('播放失敗: ' + err.message);
            });
        };

        const copyToClipboard = (text) => {
            navigator.clipboard.writeText(text).then(() => {
                alert('已複製到剪貼簿');
            }).catch((err) => {
                alert('複製失敗: ' + err.message);
            });
        };

        window.addEventListener('load', () => {
            log('測試工具已就緒', 'success');
            log('輸入影片 URL 並點擊「開始測試」', 'info');
        });

        const searchInPreview = () => {
            const preview = document.getElementById('htmlPreview');
            const searchTerm = prompt('搜尋關鍵字 (例如: m3u8, mp4, source, cdn):');
            if (!searchTerm) return;

            const text = preview.textContent;
            const regex = new RegExp(`[^\\s"'<>]*${searchTerm}[^\\s"'<>]*`, 'gi');
            const matches = text.match(regex) || [];
            
            const uniqueMatches = [...new Set(matches)];
            log(`在預覽中找到 ${uniqueMatches.length} 個相關結果:`, 'info');
            
            uniqueMatches.forEach((match, i) => {
                if (match.length < 300) {
                    log(`${i + 1}. ${match}`, 'info');
                }
            });
        };

        const testWithNetworkMonitor = async () => {
            clearLog();
            const videoUrl = document.getElementById('videoUrl').value;
            
            if (!videoUrl) {
                log('請輸入影片 URL', 'error');
                return;
            }

            log('開始網路監聽測試: ' + videoUrl, 'info');
            log('⚠️ 此方法需要在實際瀏覽器中訪問頁面', 'error');
            log('無法在測試工具中直接監聽，建議步驟：', 'info');
            log('1. 在新標籤頁訪問: ' + videoUrl, 'info');
            log('2. 按 F12 打開開發者工具', 'info');
            log('3. 切換到「Network」標籤', 'info');
            log('4. 重新加載頁面', 'info');
            log('5. 尋找類型為「XHR」或「Fetch」的請求，包含 m3u8 或 mp4', 'info');
            log('6. 在「Response」中查看實際流 URL', 'info');
            log('', 'info');
            log('或者，嘗試在控制台執行以下代碼:', 'info');
            
            const code = `
// 截取所有 fetch 請求
const originalFetch = window.fetch;
window.fetch = function(...args) {
    console.log('[Fetch Intercept]', args[0]);
    return originalFetch.apply(this, args);
};

// 查看所有 video 元素的 src
document.querySelectorAll('video').forEach((v, i) => {
    console.log('Video ' + i + ':', v.src, v.currentSrc);
    if (v.children) {
        [...v.children].forEach(child => {
            console.log('  - Child:', child.src || child.data);
        });
    }
});
            `;
            
            log('代碼:', 'info');
            log(code, 'info');
        };
    </script>
</body>
</html>
